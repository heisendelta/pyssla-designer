import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import cv2
from collections import Counter

# -----------------------------------------
# generated by "claude-3-7-sonnet-20250219"
# -----------------------------------------

def claude_downscale_nearest_neighbor(img, canvas_size):
    height, width, _ = img.shape
    canvas_width, canvas_height = canvas_size
    
    scale_h = height / canvas_height
    scale_w = width / canvas_width
    
    downscaled = np.zeros((canvas_height, canvas_width, 3), dtype=np.uint8)

    for i in range(canvas_height):
        for j in range(canvas_width):
            x = int(i * scale_h)
            y = int(j * scale_w)
            downscaled[i, j] = img[x, y]
    return downscaled

def claude_downscale_averaging(img, canvas_size):
    height, width, _ = img.shape
    canvas_width, canvas_height = canvas_size
    
    scale_h = height / canvas_height
    scale_w = width / canvas_width
    
    downscaled = np.zeros((canvas_height, canvas_width, 3), dtype=np.uint8)

    for i in range(canvas_height):
        for j in range(canvas_width):
            x_start = int(i * scale_h)
            y_start = int(j * scale_w)
            x_end = int((i + 1) * scale_h)
            y_end = int((j + 1) * scale_w)
            downscaled[i, j] = np.mean(img[x_start:x_end, y_start:y_end], axis=(0, 1))
    return downscaled.astype(np.uint8)

def claude_downscale_mean(img, canvas_size):
    height, width, _ = img.shape
    canvas_width, canvas_height = canvas_size
    
    scale_h = height / canvas_height
    scale_w = width / canvas_width
    
    downscaled = np.zeros((canvas_height, canvas_width, 3), dtype=np.uint8)

    for i in range(canvas_height):
        for j in range(canvas_width):
            x_start = int(i * scale_h)
            y_start = int(j * scale_w)
            x_end = int((i + 1) * scale_h)
            y_end = int((j + 1) * scale_w)
            downscaled[i, j] = np.mean(img[x_start:x_end, y_start:y_end], axis=(0, 1)).astype(np.uint8)
    return downscaled

def claude_downscale_convolution(img, canvas_size, kernel_size=3):
    height, width, _ = img.shape
    canvas_width, canvas_height = canvas_size
    
    scale_h = height / canvas_height
    scale_w = width / canvas_width
    
    downscaled = np.zeros((canvas_height, canvas_width, 3), dtype=np.uint8)

    for i in range(canvas_height):
        for j in range(canvas_width):
            x_start = int(i * scale_h)
            y_start = int(j * scale_w)
            x_end = int((i + 1) * scale_h)
            y_end = int((j + 1) * scale_w)
            region = img[x_start:x_end, y_start:y_end]
            if region.size > 0:  # Ensure region is not empty
                blurred = cv2.blur(region, (kernel_size, kernel_size))
                downscaled[i, j] = np.mean(blurred, axis=(0, 1)).astype(np.uint8)
    return downscaled

# -----------------------------------------
# generated by "gemini-2.5-flash"
# -----------------------------------------

def gemini_downscale_mode_pooling(img, canvas_size):
    height, width, _ = img.shape
    canvas_width, canvas_height = canvas_size
    
    scale_h = height / canvas_height
    scale_w = width / canvas_width
    
    downscaled = np.zeros((canvas_height, canvas_width, 3), dtype=np.uint8)

    for i in range(canvas_height):
        for j in range(canvas_width):
            x_start = int(i * scale_h)
            y_start = int(j * scale_w)
            x_end = int((i + 1) * scale_h)
            y_end = int((j + 1) * scale_w)
            
            region = img[x_start:x_end, y_start:y_end].reshape(-1, 3) # Flatten pixels to (N, 3)
            
            if region.size > 0:
                # Convert RGB tuples to hashable string/tuple for Counter
                pixel_colors = [tuple(p) for p in region]
                
                # Find the most common color
                most_common = Counter(pixel_colors).most_common(1)
                if most_common:
                    downscaled[i, j] = np.array(most_common[0][0])
                else:
                    downscaled[i, j] = [0, 0, 0] # Default to black if no pixels (shouldn't happen with proper scaling)
            else:
                downscaled[i, j] = [0, 0, 0] # Default to black
    return downscaled

def gemini_downscale_median_pooling(img, canvas_size):
    height, width, _ = img.shape
    canvas_width, canvas_height = canvas_size
    
    scale_h = height / canvas_height
    scale_w = width / canvas_width
    
    downscaled = np.zeros((canvas_height, canvas_width, 3), dtype=np.uint8)

    for i in range(canvas_height):
        for j in range(canvas_width):
            x_start = int(i * scale_h)
            y_start = int(j * scale_w)
            x_end = int((i + 1) * scale_h)
            y_end = int((j + 1) * scale_w)
            
            region = img[x_start:x_end, y_start:y_end]
            
            if region.size > 0:
                downscaled[i, j] = np.median(region, axis=(0, 1)).astype(np.uint8)
            else:
                downscaled[i, j] = [0, 0, 0] # Default to black
    return downscaled


def gemini_downscale_opencv_nearest(img, canvas_size):
    # OpenCV expects (width, height) for size argument
    canvas_width, canvas_height = canvas_size 
    
    # cv2.resize automatically handles the interpolation
    downscaled = cv2.resize(img, (canvas_width, canvas_height), interpolation=cv2.INTER_NEAREST)
    return downscaled


def gemini_downscale_pre_sharpened_nearest(img, canvas_size, sharpen_kernel=None):
    # Define a common sharpening kernel
    if sharpen_kernel is None:
        sharpen_kernel = np.array([
            [0, -1, 0],
            [-1, 5, -1],
            [0, -1, 0]
        ], dtype=np.float32)

    # Apply sharpening
    # Use cv2.filter2D for convolution, result can have values outside 0-255
    sharpened_img = cv2.filter2D(img, -1, sharpen_kernel) # -1 means output depth same as input
    
    # Clip values to 0-255 range and convert to uint8
    sharpened_img = np.clip(sharpened_img, 0, 255).astype(np.uint8)

    return claude_downscale_nearest_neighbor(sharpened_img, canvas_size)
